\documentclass[12pt]{article}

% To prevent nasty underfull boxes
\usepackage[italian]{babel}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}
% Multipart figures
%\usepackage{subfigure}
% More symbols
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{latexsym}

% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

% Packages to include algorithms in the document
\usepackage{algpseudocode} 
\usepackage{algorithm}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi
\newtheorem{theorem}{Teorema}[section] 
\newtheorem{lemma}[theorem]{Lemma} 
\newtheorem{proposition}[theorem]{Proposizione} 
\newtheorem{corollary}[theorem]{Corollario}

\newenvironment{proof}[1][Dimostrazione.]{ 
\begin{trivlist}
	\item[\hskip \labelsep {\bfseries #1}]}{ 
\end{trivlist}
} 
\newenvironment{definition}[1][Definizione.]{ 
\begin{trivlist}
	\item[\hskip \labelsep {\bfseries #1}]}{ 
\end{trivlist}
} 
\newenvironment{example}[1][Esempio.]{ 
\begin{trivlist}
	\item[\hskip \labelsep {\bfseries #1}]}{ 
\end{trivlist}
} 
\newenvironment{remark}[1][Osservazione.]{ 
\begin{trivlist}
	\item[\hskip \labelsep {\bfseries #1}]}{ 
\end{trivlist}
}

% Black QED tombstone
% \newcommand{\qed}{\nobreak \ifvmode \relax \else
%       \ifdim\lastskip<1.5em \hskip-\lastskip
%       \hskip1.5em plus0em minus0.5em \fi \nobreak
%       \vrule height0.75em width0.5em depth0.25em\fi}
% White QED box
\newcommand{\qed}{\hfill \ensuremath{\Box}}

\ifpdf 
\usepackage[pdftex]{graphicx} \else 
\usepackage{graphicx} \fi 
\title{Tre algoritmi per ordinare con informazione parziale} 
\author{Jacopo Notarstefano}

\begin{document}

\ifpdf \DeclareGraphicsExtensions{.pdf, .jpg, .tif} \else \DeclareGraphicsExtensions{.eps, .jpg} \fi

\maketitle

% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ %
\section{Alcuni teoremi di interesse}

Dato un grafo \(G\) possiamo trovarne una partizione in insiemi indipendenti tramite l'algoritmo goloso che prova ad espandere 
\begin{definition}
	Sia \(G\) un grafo perfetto e sia \(\left\{S_1,\dots,S_k\right\}\) una sua partizione ottenuta con il precedente algoritmo goloso. Chiameremo \emph{punto goloso} il punto \(x\) definito da
	\[x=\sum_{i=1}^k\frac{|S_i|}{n}\chi^{S_i}\]
\end{definition}
\begin{theorem}
	Sia \(G\) un grafo perfetto su \(n\) vertici e sia \(x\) un suo punto goloso. Allora, comunque fissato \(\varepsilon>0\), vale
	\[H(x)\le(1+\varepsilon)H(G)+(1+\varepsilon)\log\left(1+\frac{1}{\varepsilon}\right)\]
\end{theorem}
\begin{proof}
	Sia \(S_1,\dots,S_k\) la sequenza di insiemi indipendenti prodotta dall'algoritmo goloso. Di conseguenza \(S_1\) è un insieme indipendente e massimale in \(G\), mentre \(S_2\) è indipendente e massimale in \(G-S_1\) e così via. Sia \(\delta>0\) fissato. Per ogni vertice \(v\in V\) poniamo \(m(v)\) l'unico indice in \(\left\{1,\dots,k\right\}\) tale che \(v\in S_m(v)\). Definiamo allora un punto \(z\) di componenti date da
	\[z_v=\frac{\delta}{n}\left(\frac{1}{\tilde{x_v}}\right)^{1-\delta}=\frac{\delta}{n}\left(\frac{n}{|S_m(v)|}\right)^{1-\delta}=\frac{\delta}{n^{\delta}}\left(\frac{1}{|S_m(v)|}\right)^{1-\delta}\]
\end{proof}

% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ %
\section{Insertion sort} 
\begin{lemma}
	Sia \(P\) un insieme parzialmente ordinato di cardinalità \(n\) e sia \(C\) una catena di lunghezza massima in \(P\). Vale allora \(\left|C\right|\ge n\cdot2^{-H(\overline{P})}\). 
\end{lemma}
\begin{theorem}
	L'algoritmo \(1\) compie 
\end{theorem}

% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ %
\section{Merge sort naive}

% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ %
\section{Merge sort} 
\begin{definition}
	Sia \(K\) una componente connessa di \(G(x)\). Se \(K\) è rossa chiamo \(A\cap K\) \emph{catena maggiore} e \(B\cap K\) \emph{catena minore}. Se \(K\) è blu il contrario. 
\end{definition}
\begin{definition}
	Sia \(K\) una componente connessa di \(G(x)\). Dico che \(K\) è \emph{buona} se ogni arco di \(G\) che possiede un estremo nella catena minore di \(K\) ha l'altro estremo nella catena maggiore oppure in una componente connessa di colore opposto. 
\end{definition}
\begin{lemma}
	Sia \(x\in \text{STAB}(G)\) localmente ottimo. Se \(G(x)\) possiede almeno una componente rossa non banale allora una di esse è buona. 
\end{lemma}
\begin{proof}
	Sia \(K\) una componente connessa rossa non banale tale che \(\frac{|A\cap K|}{|K|}\) sia minimo. Vogliamo dimostrare che \(K\) è buona. Sia \(v\in B\cap K\) e sia \(w\) adiacente a \(v\) in \(G\) ma non in \(G(x)\). Per definizione l'arco di estremi \(v\) e \(w\) non è stretto, quindi \(x_v+x_w<1\). In particolare \(x_w<1\), quindi \(w\) appartiene ad una qualche componente connessa \(L\) non banale. Se per assurdo \(L\) fosse rossa per ipotesi \(\frac{|A\cap L|}{|L|}\ge\frac{|A\cap K|}{|K|}\), dunque per ottimalità di \(x\) avremo
	\[x_v+x_w=\frac{|B\cap K|}{|K|}+\frac{|A\cap L|}{|L|}\ge\frac{|B\cap K|}{|K|}+\frac{|A\cap K|}{|K|}\ge 1\]
	da cui dedurremmo che l'arco di estremi \(v\) e \(w\) è stretto, una contraddizione. Segue quindi che \(L\) è blu oppure non esiste \(w\) adiacente a \(v\) in \(G\) ma non in \(G(x)\), cioè la tesi. 
\end{proof}

\bibliographystyle{plain} 
\bibliography{} \end{document} 
